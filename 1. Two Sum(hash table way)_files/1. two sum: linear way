# 簡單的方法就是用兩層迴圈

第一層迴圈由矩陣的第[0]開始尋找，直到第n個。第二個迴圈由i+1開始找。如果有找到就結束迴圈。但是這方非常耗時間，因為要使用O(n^2)的時間複雜度。所以等等會介紹hash table，此用空間來換取時間。如下表，target為4，矩陣為[2,1,5,3]當跑第一次迴圈的時候找到2+1,2+5,2+3。當跑第二次迴圈的時候比對1+5,1+3。其中1+3=4就是我們的target也就是答案了。但有沒有想過當第一次跑的時候比對到2+3我們其實已經找到3這個數字了，所以如果有一張表可以記錄這些可能的數字，這樣只需要一次就可以照到答案了。

![Untitled](%5B%20Leetcode%20in%20C%20%5D%201%20Two%20Sum(hash%20table%20way)%2054c38188643242fd9846043920c5dc2e/Untitled.png)

```c

int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int *ans = malloc( sizeof(int) * 2 );
    for(int i=0; i<numsSize ;i++ ){
        for(int j=i+1 ; j<numsSize ; j++ ){
            if( ( nums[i] + nums[j] ) == target){
                ans[0]=i;
                ans[1]=j;
            }
        }
    }
    * returnSize =2;
    return ans;
}
```
